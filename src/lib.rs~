use ndarray::prelude::*;

use std::fmt;

////////////////////

type Usize2 = (usize, usize);
type Isize2 = (isize, isize);

enum Direction {
    Up,
    Down,
    Left,
    Right,
}

impl Direction {
    fn to_hello(&self) -> Isize2 {
        match self {
            Direction:Up => (0, 1),
            Direction:Down => (0, -1),
            Direction:Left => (-1, 0),
            Direction:Right => (1, 0),
        }
    }
}

pub trait Puzzle<T> {
    fn shape(&self) -> Usize2;

    fn slide_from(&mut self, idx: Usize2);
    fn slide_to(&mut self, direction: Direction, distance: usize);
}

////////////////////

pub struct StackPuzzle<
    const WIDTH: usize,
    const HEIGHT: usize,
    T: Copy,
> {
    inner: [[T; HEIGHT]; WIDTH]
}

impl Default for StackPuzzle<4, 4, u8> {
    fn default() -> Self {
        Self {
            inner: [
                [ 1,  2,  3,  4],
                [ 5,  6,  7,  8],
                [ 9, 10, 11, 12],
                [13, 14, 15,  0],
            ]
        }
    }
}

impl<
    const WIDTH: usize,
    const HEIGHT: usize,
    T: Copy,
> StackPuzzle<WIDTH, HEIGHT, T> {
    unsafe fn slide_unchecked(&mut self) {}
}

impl<
    const WIDTH: usize,
    const HEIGHT: usize,
    T: Copy + fmt::Debug,
> fmt::Debug for StackPuzzle<WIDTH, HEIGHT, T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{:?}", self.inner)
    }
}

////////////////////

pub struct NdArrayPuzzle<T: Copy> {
    inner: Array2<T>
}

impl Default for NdArrayPuzzle<u8> {
    fn default() -> Self {
        Self {
            inner: array![
                [ 1,  2,  3,  4],
                [ 5,  6,  7,  8],
                [ 9, 10, 11, 12],
                [13, 14, 15,  0],
            ].reversed_axes()
        }
    }
}

impl<T: Copy + fmt::Display> fmt::Debug for NdArrayPuzzle<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.inner.t())
    }
}

